<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MinimumSpanningTree.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">library</a> &gt; <a href="index.source.html" class="el_package">display.minimumSpanningTree.implementation</a> &gt; <span class="el_source">MinimumSpanningTree.kt</span></div><h1>MinimumSpanningTree.kt</h1><pre class="source lang-java linenums">package display.minimumSpanningTree.implementation

import display.minimumSpanningTree.GraphMST
import graph.Graph
import graph.abstracts.AbstractGraph

/**
 * Works efficiently for graphs that already have a vertex map.
 * For those that don't, you're going to have to implement your own function :)
 */
<span class="fc" id="L11">class GraphMSTWithKruskal &lt;V, E&gt; : GraphMST&lt;V, E&gt; {</span>
    override fun getMST(graph: Graph&lt;V, E&gt;) : Set&lt;E&gt;? {
<span class="fc" id="L13">        val mst = mutableSetOf&lt;E&gt;()</span>
<span class="fc bfc" id="L14" title="All 2 branches covered.">        if (graph.configuration.isDirected()) {</span>
<span class="fc" id="L15">            return null</span>
        }
<span class="fc bfc" id="L17" title="All 2 branches covered.">        return if (graph.configuration.isUnweighted()) getMSTUnweighted(graph, mst) else getMSTWeighted(graph, mst)</span>
    }

<span class="fc" id="L20">    private class DisjointSetUnion(numberOfVertices: Int) {</span>
<span class="fc bfc" id="L21" title="All 2 branches covered.">        private val parent = IntArray(numberOfVertices) { it }</span>
<span class="fc bfc" id="L22" title="All 2 branches covered.">        private val rank = IntArray(numberOfVertices) { 1 }</span>

        fun find(a: Int) : Int {
<span class="fc bfc" id="L25" title="All 2 branches covered.">            if (parent[a] != a) {</span>
<span class="fc" id="L26">                parent[a] = find(parent[a])</span>
            }
<span class="fc" id="L28">            return parent[a]</span>
        }

        fun union(a: Int, b: Int) : Boolean {
<span class="fc" id="L32">            val rootA = find(a)</span>
<span class="fc" id="L33">            val rootB = find(b)</span>
<span class="fc bfc" id="L34" title="All 2 branches covered.">            if (rootA == rootB) return false</span>

<span class="fc bfc" id="L36" title="All 2 branches covered.">            if (rank[rootA] &gt; rank[rootB]) {</span>
<span class="fc" id="L37">                parent[rootB] = rootA</span>
<span class="fc bfc" id="L38" title="All 2 branches covered.">            } else if (rank[rootA] &lt; rank[rootB]) {</span>
<span class="fc" id="L39">                parent[rootA] = rootB</span>
            } else {
<span class="fc" id="L41">                parent[rootB] = rootA</span>
<span class="fc" id="L42">                rank[rootA]++</span>
            }
<span class="fc" id="L44">            return true</span>
        }
    }

    private fun getMSTWeighted(graph: Graph&lt;V, E&gt;, mst: MutableSet&lt;E&gt;) : Set&lt;E&gt; {
<span class="fc" id="L49">        val disjointSetUnion = DisjointSetUnion(graph.getNOfVertices())</span>
<span class="fc" id="L50">        val edges = graph.edgeSet().toList().sortedBy { graph.getEdgeWeight(it) }</span>

<span class="fc" id="L52">        val verticesMap = graph.getVerticesMap()</span>
<span class="fc bfc" id="L53" title="All 2 branches covered.">        if (verticesMap.isEmpty()) return setOf()</span>

<span class="fc" id="L55">        edges.forEach { edge -&gt;</span>
<span class="fc" id="L56">            val tail = graph.getEdgeTail(edge)</span>
<span class="fc" id="L57">            val head = graph.getEdgeHead(edge)</span>
<span class="pc bpc" id="L58" title="2 of 4 branches missed.">            if (tail != null &amp;&amp; head != null) {</span>
<span class="fc" id="L59">                val tailIndex = verticesMap[tail]</span>
<span class="fc" id="L60">                val headIndex = verticesMap[head]</span>
<span class="pc bpc" id="L61" title="2 of 4 branches missed.">                if (tailIndex != null &amp;&amp; headIndex != null) {</span>
<span class="fc bfc" id="L62" title="All 2 branches covered.">                    if (disjointSetUnion.union(tailIndex, headIndex)) {</span>
<span class="fc" id="L63">                        mst.add(edge)</span>
                    }
                }
            }
<span class="fc" id="L67">        }</span>
<span class="fc" id="L68">        return mst</span>
    }

    private fun getMSTUnweighted(graph: Graph&lt;V, E&gt;, mst: MutableSet&lt;E&gt;) : Set&lt;E&gt; {
<span class="fc" id="L72">        val queue = ArrayDeque&lt;V&gt;()</span>
<span class="fc" id="L73">        val hashSet = HashSet&lt;V&gt;()</span>
<span class="fc" id="L74">        queue.addFirst(graph.vertexSet().first())</span>
<span class="fc bfc" id="L75" title="All 4 branches covered.">        while (queue.isNotEmpty()) {</span>
<span class="fc" id="L76">            val current = queue.removeFirst()</span>
<span class="fc bfc" id="L77" title="All 2 branches covered.">            for (edge in graph.outgoingEdgesOf(current)) {</span>
<span class="fc" id="L78">                val tail = graph.getEdgeTail(edge)</span>
<span class="fc" id="L79">                val head = graph.getEdgeHead(edge)</span>
<span class="fc bfc" id="L80" title="All 4 branches covered.">                val neighbour = if (tail != current) tail else if (head != current) head else continue</span>
<span class="fc bfc" id="L81" title="All 2 branches covered.">                if (neighbour !in hashSet) {</span>
<span class="fc" id="L82">                    hashSet.add(neighbour)</span>
<span class="fc" id="L83">                    queue.addFirst(neighbour)</span>
<span class="fc" id="L84">                    mst.add(edge)</span>
                }
            }
        }
<span class="fc" id="L88">        return mst</span>
    }
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>